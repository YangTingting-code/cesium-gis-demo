<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <title>Cesium 无依赖热力图</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.112/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.112/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html,
    body,
    #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>
  <script>
    /* ==========  1. 初始化 Viewer  ========== */
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJlYWE1OWUxNy1mMWZiLTRhNmQtYTJiZC1hNGE5NWMzMjU1MGEiLCJpZCI6NTc3MzMsImlhdCI6MTYyNzg0NTE4Mn0.XcKpgANiY19MC4bdFUXMVEBToBmqS8kuYpUlxJHYZxk';
    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrain: Cesium.Terrain.fromWorldTerrain(),
      baseLayerPicker: false,
      geocoder: false,
      homeButton: false,
      sceneModePicker: false,
      navigationHelpButton: false,
      animation: false,
      timeline: false,
      fullscreenButton: false,
      vrButton: false
    });

    viewer.scene.globe.depthTestAgainstTerrain = true;

    /* ==========  2. 随机测试数据 200 个点  ========== */
    const points = [];
    for (let i = 0; i < 200; i++) {
      points.push({
        lon: 116.3 + Math.random() * 0.3,
        lat: 39.9 + Math.random() * 0.3,
        value: Math.random()      // 0~1
      });
    }

    /* ==========  3. 网格参数  ========== */
    const gridSize = 128;
    const bounds = { west: 116.2, east: 116.6, south: 39.85, north: 40.15 };

    /* ==========  4. IDW 插值 + 高度/颜色映射  ========== */
    function idw(gridX, gridY) {
      let sum = 0, weightSum = 0;
      const x = bounds.west + (gridX / (gridSize - 1)) * (bounds.east - bounds.west);
      const y = bounds.south + (gridY / (gridSize - 1)) * (bounds.north - bounds.south);
      points.forEach(p => {
        const dx = (p.lon - x) * 111000 * Math.cos(y * Math.PI / 180);
        const dy = (p.lat - y) * 111000;
        const d2 = dx * dx + dy * dy + 1e-8;
        const w = 1 / d2;
        sum += p.value * w;
        weightSum += w;
      });
      return Cesium.Math.clamp(sum / weightSum, 0, 1);
    }

    function heatColor(t) {
      // HSL 240°(蓝) → 0°(红)
      t = Cesium.Math.clamp(t, 0, 1);
      const hue = (1 - t) * 240 / 360;
      return Cesium.Color.fromHsl(hue, 1, 0.5, 0.9);
    }

    /* ==========  5. 构造 Geometry  ========== */
    const positions = [];
    const colors = [];
    const indices = [];
    const minH = 0, maxH = 500;

    for (let j = 0; j < gridSize; j++) {
      for (let i = 0; i < gridSize; i++) {
        const t = idw(i, j);
        const h = minH + t * (maxH - minH);

        const lon = bounds.west + (i / (gridSize - 1)) * (bounds.east - bounds.west);
        const lat = bounds.south + (j / (gridSize - 1)) * (bounds.north - bounds.south);

        positions.push(lon, lat, h);
        colors.push(heatColor(t));
      }
    }

    for (let j = 0; j < gridSize - 1; j++) {
      for (let i = 0; i < gridSize - 1; i++) {
        const idx = j * gridSize + i;
        indices.push(idx, idx + 1, idx + gridSize);
        indices.push(idx + 1, idx + gridSize + 1, idx + gridSize);
      }
    }

    const geometry = new Cesium.Geometry({
      attributes: {
        position: new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.DOUBLE,
          componentsPerAttribute: 3,
          values: new Float64Array(positions)
        }),
        color: new Cesium.GeometryAttribute({
          componentDatatype: Cesium.ComponentDatatype.FLOAT,
          componentsPerAttribute: 4,
          values: new Float32Array(colors.flatMap(c => [c.red, c.green, c.blue, c.alpha]))
        })
      },
      indices: new Uint32Array(indices),
      primitiveType: Cesium.PrimitiveType.TRIANGLES,
      boundingSphere: Cesium.BoundingSphere.fromVertices(positions)
    });

    const instance = new Cesium.GeometryInstance({ geometry });

    viewer.scene.primitives.add(new Cesium.Primitive({
      geometryInstances: instance,
      appearance: new Cesium.PerInstanceColorAppearance({
        flat: false,
        translucent: true
      }),
      asynchronous: false
    }));

    /* ==========  6. 视角飞过去  ========== */
    viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(116.4, 40.0, 2000),
      orientation: {
        heading: 0,
        pitch: Cesium.Math.toRadians(-30),
        roll: 0
      }
    });
  </script>
</body>

</html>